package nu.huw.clarity.db;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.StrictMode;
import android.util.Log;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import nu.huw.clarity.BuildConfig;
import nu.huw.clarity.db.DatabaseContract.Contexts;
import nu.huw.clarity.db.DatabaseContract.Folders;
import nu.huw.clarity.db.DatabaseContract.Tasks;

/**
 * Once we've pulled in all the sync data, there's a lot of data in columns that needs to be
 * generated by OmniFocus, like countsâ€”these can all be done programmatically at the end of a sync,
 * so that's what Omni do.
 *
 * This class contains these methods, which recursively update counts, and also registries of
 * children and the next task the user wants to do.
 *
 * This is pretty much the most confusing and complicated class in the entire application. I'm
 * really sorry. It sucks.
 */
public class RecursiveColumnUpdater {

  private static final String TAG = RecursiveColumnUpdater.class.getSimpleName();
  ContentValues mBlockedValue = new ContentValues();
  private DatabaseHelper mDBHelper;
  private Context androidContext;

  public RecursiveColumnUpdater(Context context) {

    // Strict mode for debugging

    if (BuildConfig.DEBUG) {
      StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects()
          .detectLeakedClosableObjects()
          .penaltyLog().penaltyDeath()
          .build());
    }

    androidContext = context;

    mDBHelper = new DatabaseHelper(context);
    mBlockedValue.put(Tasks.COLUMN_BLOCKED, true);
  }

  /**
   * Build the tree into the database, and any other cell data that is built after a sync instead
   * of handed down with the rest of the data.
   *
   * This works in one big recursive traversal of the tree. It takes some time, so it's designed
   * to be called after a full initial sync, or in other occasions where everything is totally
   * messy.
   *
   * Steps:
   * 1. Iterate through each child of a top-level project
   * 2. Fill down the project's effective attributes
   * 3. Push & Pop
   * 4. Fill up child counts
   * 5. Calculate due dates & overdues
   */
  public void updateTree() {

    SQLiteDatabase db = mDBHelper.getWritableDatabase();

    TreeOperations tree = new TreeOperations(androidContext);

    Log.i(TAG, "Updating attributes for contexts");

    tree.updateAttributesForContext(null);

    Log.i(TAG, "Updating attributes for projects/tasks");

    tree.updateAttributesForSubtree(null);

    // Now, again for projects, but we're just counting now. This loop isn't recursive by any
    // means, which is good for system resources! More speed!

    Log.i(TAG, "Counting project children");

    String[] projectColumns = new String[]{Tasks.COLUMN_ID, Tasks.COLUMN_PARENT_ID};
    Cursor projects = mDBHelper
        .query(db, Tasks.TABLE_NAME, projectColumns, Tasks.COLUMN_PROJECT + "='1'");

    HashMap<String, Integer[]> folderCounts = new HashMap<>();

    while (projects.moveToNext()) {

      int countChildren, countAvailable, countCompleted, countDueSoon, countOverdue,
          countRemaining;

      String id = mDBHelper.getString(projects, Tasks.COLUMN_ID);

      updateProjectCounts(db, id);

      Cursor countChildrenCursor = mDBHelper
          .query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_PROJECT_ID + "=?",
              new String[]{id});
      Cursor countAvailableCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
          Tasks.COLUMN_PROJECT_ID + "=? AND " +
              Tasks.COLUMN_DATE_COMPLETED +
              " IS NULL AND " + Tasks.COLUMN_BLOCKED +
              "=0 AND " +
              Tasks.COLUMN_BLOCKED_BY_DEFER +
              "=0 AND " +
              Tasks.COLUMN_HAS_CHILDREN + "=0",
          new String[]{id});
      Cursor countRemainingCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
          Tasks.COLUMN_PROJECT_ID + "=? AND " +
              Tasks.COLUMN_DATE_COMPLETED + " IS NULL",
          new String[]{id});
      Cursor countDueSoonCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
          Tasks.COLUMN_PROJECT_ID + "=? AND " +
              Tasks.COLUMN_DUE_SOON + "=1",
          new String[]{id});
      Cursor countOverdueCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
          Tasks.COLUMN_PROJECT_ID + "=? AND " +
              Tasks.COLUMN_OVERDUE + "=1",
          new String[]{id});

      // Note that countCompleted + countRemaining = countChildren, so we can save on an
      // extra SQL query each time.

      countChildren = countChildrenCursor.getCount();
      countAvailable = countAvailableCursor.getCount();
      countRemaining = countRemainingCursor.getCount();
      countCompleted = countChildren - countRemaining;
      countDueSoon = countDueSoonCursor.getCount();
      countOverdue = countOverdueCursor.getCount();

      countChildrenCursor.close();
      countAvailableCursor.close();
      countRemainingCursor.close();
      countDueSoonCursor.close();
      countOverdueCursor.close();

      ContentValues values = new ContentValues();

      // There's no point wasting resources on a call which is going to zero out columns
      // which are already set to zero. This is much more efficient if we only update the
      // columns which have counts.

      if (countChildren > 0) {
        values.put(Tasks.COLUMN_COUNT_CHILDREN, countChildren);
      }
      if (countAvailable > 0) {
        values.put(Tasks.COLUMN_COUNT_AVAILABLE, countAvailable);
      }
      if (countCompleted > 0) {
        values.put(Tasks.COLUMN_COUNT_COMPLETED, countCompleted);
      }
      if (countDueSoon > 0) {
        values.put(Tasks.COLUMN_COUNT_DUE_SOON, countDueSoon);
      }
      if (countOverdue > 0) {
        values.put(Tasks.COLUMN_COUNT_OVERDUE, countOverdue);
      }
      if (countRemaining > 0) {
        values.put(Tasks.COLUMN_COUNT_REMAINING, countRemaining);
      }

      // And if none of them have counts (an empty project, for some reason), don't update
      // anything.

      if (values.size() > 0) {
        db.update(Tasks.TABLE_NAME, values, Tasks.COLUMN_ID + "=?", new String[]{id});
      }

      String parentID = mDBHelper.getString(projects, Tasks.COLUMN_PARENT_ID);
      if (parentID != null) {

        Integer[] childCounts =
            {countChildren, countAvailable, countCompleted, countDueSoon, countOverdue,
                countRemaining};

        if (folderCounts.containsKey(parentID)) {
          for (int j = 0; j < childCounts.length; j++) {
            folderCounts.get(parentID)[j] += childCounts[j];
          }
        } else {
          folderCounts.put(parentID, childCounts);
        }
      }
    }

    projects.close();

    // Finally, kick off the folder updater. This sorts out the child counts of folders,
    // which need to show their numbers.

    // We need a LinkedList because we're adding and removing objects. This is really hacky
    // because I did it at like half past midnight and I really wanted to sleep. So I kinda
    // understand how it works, but at the same time, I don't. It _is_ pretty fast though,
    // somehow.

    Log.i(TAG, "Counting folder children");

    List<Object> array = new LinkedList<>(Arrays.asList(folderCounts.keySet().toArray()));
    while (!array.isEmpty()) {
      String id = (String) array.get(0);

      // This bit just gets the ID of the folder's parent
      Cursor cursor = mDBHelper
          .query(db, Folders.TABLE_NAME, new String[]{Folders.COLUMN_PARENT_ID},
              Folders.COLUMN_ID + " = ?", new String[]{id});
      if (cursor != null && cursor.moveToFirst()) {
        String parentID = mDBHelper.getString(cursor, Folders.COLUMN_PARENT_ID);

        Integer[] childCounts = folderCounts.get(id);

        // Add up the child counts for the folder

        if (folderCounts.containsKey(parentID)) {
          for (int j = 0; j < childCounts.length; j++) {
            folderCounts.get(parentID)[j] =
                folderCounts.get(parentID)[j] + childCounts[j];
          }
        } else {

          // If this folder isn't in our HashMap yet, add it. But also add an extra
          // iteration to this loop.

          if (parentID != null) {
            folderCounts.put(parentID, childCounts);
            array.add(parentID);
          }
        }
      }

      if (cursor != null) {
        cursor.close();
      }

      // Could probably be better handled than this, but it works.
      array.remove(0);
    }

    // Simply add each Folder's new counts to the database.

    for (String id : folderCounts.keySet()) {
      Integer[] childCounts = folderCounts.get(id);
      ContentValues values = new ContentValues();

      values.put(Tasks.COLUMN_COUNT_CHILDREN, childCounts[0]);
      values.put(Tasks.COLUMN_COUNT_AVAILABLE, childCounts[1]);
      values.put(Tasks.COLUMN_COUNT_COMPLETED, childCounts[2]);
      values.put(Tasks.COLUMN_COUNT_DUE_SOON, childCounts[3]);
      values.put(Tasks.COLUMN_COUNT_OVERDUE, childCounts[4]);
      values.put(Tasks.COLUMN_COUNT_REMAINING, childCounts[5]);

      db.update(Folders.TABLE_NAME, values, Folders.COLUMN_ID + " = ?", new String[]{id});
    }

    db.close();
  }

  /**
   * Given a database and some other info, find the task's children (if any), and update them
   * with
   * their parent's dateDue and dateDefer. We iterate over any element which lists the task's ID
   * as its parent, and fill in the parent's data in their 'effective' fields.
   *
   * Once this is done, we check to see if the child has any of the same info to pass down to its
   * descendants. If there are any, we update the row.
   *
   * Then, finally, we recursively call the function again on each of these children, until we've
   * eventually descended the tree.
   */
  private void updateProjectChildren(SQLiteDatabase db, String id, String projectID,
      String dateDefer, String dateDue, String flagged,
      String status, String type) {

    String[] columns = new String[]{Tasks.COLUMN_ID, Tasks.COLUMN_DATE_DEFER,
        Tasks.COLUMN_DATE_DUE, Tasks.COLUMN_FLAGGED,
        Tasks.COLUMN_DATE_COMPLETED,
        Tasks.COLUMN_DUE_SOON, Tasks.COLUMN_OVERDUE,
        Tasks.COLUMN_RANK, Tasks.COLUMN_PROJECT_STATUS,
        Tasks.COLUMN_TYPE, Tasks.COLUMN_BLOCKED,
        Tasks.COLUMN_BLOCKED_BY_DEFER};

    Cursor children = mDBHelper
        .query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PARENT_ID + "=?",
            new String[]{id});

    long nextRank = Long.MAX_VALUE;
    String nextID = "";

    ContentValues values = new ContentValues();
    ContentValues childValues = new ContentValues();

    // Batch set values for this item's children. Useful for cascading values (particularly
    // when the cascade isn't conditional).

    if (flagged.equals("1")) {
      childValues.put(Tasks.COLUMN_FLAGGED, flagged);
      childValues.put(Tasks.COLUMN_FLAGGED_EFFECTIVE, flagged);
    }
    childValues.put(Tasks.COLUMN_DATE_DEFER, dateDefer);
    childValues.put(Tasks.COLUMN_DATE_DEFER_EFFECTIVE, dateDefer);
    childValues.put(Tasks.COLUMN_DATE_DUE, dateDue);
    childValues.put(Tasks.COLUMN_DATE_DUE_EFFECTIVE, dateDue);
    childValues.put(Tasks.COLUMN_PROJECT_ID, projectID);
    childValues.put(Tasks.COLUMN_PROJECT_STATUS, status);

    db.update(Tasks.TABLE_NAME, childValues, Tasks.COLUMN_PARENT_ID + "=?",
        new String[]{id});

    boolean hasChildren = false;

    while (children.moveToNext()) {

      hasChildren = true;

      // This section here applies before the recursive call. Basically, all of this code
      // will fill the tree _downward_, with each call pushing deeper into the stack but
      // being able to access the data we've just set.
      //
      // For this case, each level below will be able to access the due date, defer date &
      // flagged status of the level above, which it can then apply to its own children.

      String childID = mDBHelper.getString(children, Tasks.COLUMN_ID);
      String childDateDefer = mDBHelper.getString(children, Tasks.COLUMN_DATE_DEFER);
      String childDateDue = mDBHelper.getString(children, Tasks.COLUMN_DATE_DUE);
      String childFlagged = mDBHelper.getString(children, Tasks.COLUMN_FLAGGED);
      String childStatus = mDBHelper.getString(children, Tasks.COLUMN_PROJECT_STATUS);
      String childType = mDBHelper.getString(children, Tasks.COLUMN_TYPE);
      long childRank =
          Long.valueOf(mDBHelper.getString(children, Tasks.COLUMN_RANK));

      String localDateDefer = dateDefer;
      String localDateDue = dateDue;
      String localFlagged = flagged;

      if (childDateDefer != null) {
        localDateDefer = childDateDefer;
      }
      if (childDateDue != null) {
        localDateDue = childDateDue;
      }
      if (childFlagged.equals("1")) {
        localFlagged = "1";
      }

      // Note: We don't pass child versions of `dateDefer`, `dateDue` and `dateFlagged`
      // because they're appropriately altered in the lines directly above. We don't pass
      // child versions of `blocked` and `blockedByDefer` because they're only going to
      // have been set by the subroutines above this loop, so we can get the values from
      // there without making more calls.

      updateProjectChildren(db, childID, projectID, localDateDefer, localDateDue,
          localFlagged, childStatus, childType);

      // All of the code past the recursive call will happen on the way back out, or up the
      // tree. Once each call returns, this code runs on the level above where the code was
      // just calling to.
      //
      // Here, the level above is able to access the counts for children _of each of its
      // children_. It gets really meta and confusing. Took me like 3-4 hours to work out
      // (but, to be fair, this was more bug-fixing than algorithms).

      // Add count for self (where applicable)
      boolean completed =
          mDBHelper.getString(children, Tasks.COLUMN_DATE_COMPLETED) != null;
      boolean childBlockedByDefer =
          mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER);

      // Determine next task by comparing ranks. The lower rank, when converted to a signed
      // 'long', is higher up on the list and thus the next rank. This only applied to
      // non-parallel projects, however. Also, if the task is otherwise blocked or
      // completed, it's not the next task.
      //
      // This code isn't filling upward or downward, but it is reliant on knowing whether
      // the child is blocked by a defer or not, which is calculated in
      // `updateProjectChildren()`.

      if (!completed && !childBlockedByDefer && type.equals("sequential") &&
          childRank < nextRank) {
        nextID = childID;
        nextRank = childRank;
      }
    }

    children.close();

    // Has children
    if (hasChildren) {
      values.put(Contexts.COLUMN_HAS_CHILDREN, true);
    }

    // Next task
    if (!nextID.equals("")) {
      values.put(Tasks.COLUMN_NEXT, nextID);
    }

    // Blocked tasks
    if (type.equals("sequential")) {

      // Set the 'blocked' flag for all entries which list this as a parent, where they
      // aren't the next task.

      db.update(Tasks.TABLE_NAME, mBlockedValue,
          Tasks.COLUMN_PARENT_ID + "=? AND " + Tasks.COLUMN_ID + "!=?",
          new String[]{id, nextID});
    }

    if (status.equals("dropped")) {
      values.putAll(mBlockedValue);
      values.put(Tasks.COLUMN_DROPPED, true);
    }

    // Overdue & Due Soon
    values.putAll(determineDues(db, id));

    // Update
    if (values.size() > 0) {
      db.update(Tasks.TABLE_NAME, values, Tasks.COLUMN_ID + "=?", new String[]{id});
    }
  }

  private void updateProjectCounts(SQLiteDatabase db, String id) {

    String[] columns = new String[]{Tasks.COLUMN_ID, Tasks.COLUMN_DATE_DEFER,
        Tasks.COLUMN_DATE_DUE, Tasks.COLUMN_FLAGGED,
        Tasks.COLUMN_DATE_COMPLETED,
        Tasks.COLUMN_DUE_SOON, Tasks.COLUMN_OVERDUE,
        Tasks.COLUMN_COUNT_AVAILABLE,
        Tasks.COLUMN_COUNT_CHILDREN,
        Tasks.COLUMN_COUNT_COMPLETED,
        Tasks.COLUMN_COUNT_DUE_SOON,
        Tasks.COLUMN_COUNT_OVERDUE,
        Tasks.COLUMN_COUNT_REMAINING, Tasks.COLUMN_RANK,
        Tasks.COLUMN_PROJECT_STATUS, Tasks.COLUMN_TYPE,
        Tasks.COLUMN_BLOCKED,
        Tasks.COLUMN_BLOCKED_BY_DEFER};

    Cursor children = mDBHelper
        .query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PARENT_ID + "=?",
            new String[]{id});

    int countChildren, countCompleted, countDueSoon, countOverdue, countRemaining,
        countAvailable;
    countChildren =
        countCompleted = countDueSoon = countOverdue = countRemaining = countAvailable = 0;

    ContentValues values = new ContentValues();

    while (children.moveToNext()) {

      String childID = mDBHelper.getString(children, Tasks.COLUMN_ID);

      // Descend the call stack until we hit the bottom, then build our way back up.

      // Please, if you're reading this from the future, forgive me for the terrible code.
      // It's lonely and dark in here and I really have no idea what I'm doing or how I'm
      // supposed to handle this properly. Databases are confusing and weird and I'd rather
      // build my own sync service that uses some kind of hierarchical JSON but I don't
      // have much choice.

      updateProjectCounts(db, childID);

      // All of the code past the recursive call will happen on the way back out, or up the
      // tree. Once each call returns, this code runs on the level above where the code was
      // just calling to.
      //
      // Here, the level above is able to access the counts for children _of each of its
      // children_. It gets really meta and confusing. Took me like 3-4 hours to work out
      // (but, to be fair, this was more bug-fixing than algorithms).

      // Add count for self (where applicable)
      boolean completed =
          mDBHelper.getString(children, Tasks.COLUMN_DATE_COMPLETED) != null;

      countChildren += 1;
      countCompleted += completed ? 1 : 0;
      countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_DUE_SOON);
      countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_OVERDUE);
      countRemaining += completed ? 0 : 1;

      boolean blocked = mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED);
      boolean blockedByDefer =
          mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER);

      if (!completed && !blocked && !blockedByDefer) {
        countAvailable += 1;
      }

      // Add counts for children
      countChildren += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_CHILDREN);
      countCompleted += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_COMPLETED);
      countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_DUE_SOON);
      countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_OVERDUE);
      countRemaining += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_REMAINING);
      countAvailable += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_AVAILABLE);
    }

    children.close();

    // Child counts
    if (countChildren > 0) {
      values.put(Tasks.COLUMN_COUNT_CHILDREN, countChildren);
    }
    if (countCompleted > 0) {
      values.put(Tasks.COLUMN_COUNT_COMPLETED, countCompleted);
    }
    if (countDueSoon > 0) {
      values.put(Tasks.COLUMN_COUNT_DUE_SOON, countDueSoon);
    }
    if (countOverdue > 0) {
      values.put(Tasks.COLUMN_COUNT_OVERDUE, countOverdue);
    }
    if (countRemaining > 0) {
      values.put(Tasks.COLUMN_COUNT_REMAINING, countRemaining);
    }
    if (countAvailable > 0) {
      values.put(Tasks.COLUMN_COUNT_AVAILABLE, countAvailable);
    }

    // Update
    if (values.size() > 0) {
      db.update(Tasks.TABLE_NAME, values, Tasks.COLUMN_ID + "=?", new String[]{id});
    }
  }

  /**
   * Determines whether a given task (by ID) is due soon or overdue. Returns columns to update.
   */
  private ContentValues determineDues(SQLiteDatabase db, String id) {

    ContentValues values = new ContentValues();

    Cursor dates = mDBHelper.query(db, Tasks.TABLE_NAME,
        new String[]{Tasks.COLUMN_DATE_COMPLETED,
            Tasks.COLUMN_DATE_DEFER,
            Tasks.COLUMN_DATE_DEFER_EFFECTIVE,
            Tasks.COLUMN_DATE_DUE,
            Tasks.COLUMN_DATE_DUE_EFFECTIVE},
        Tasks.COLUMN_ID + "=?", new String[]{id});

    dates.moveToNext();

    String deferDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER);
    String effectiveDeferDate =
        mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER_EFFECTIVE);
    String dueDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE);
    String effectiveDueDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE_EFFECTIVE);
    boolean completed =
        mDBHelper.getString(dates, Tasks.COLUMN_DATE_COMPLETED) != null;
    Date today = new Date();

    dates.close();

    if (!completed && (dueDate != null || effectiveDueDate != null)) {
      Date due = new Date();

      // If we don't have a normal due date, then we default back on the effective due date.
      // That one becomes the one to compare with the current date to determine Due Soon
      // and Overdue. Look up the ternary operator if this is confusing.

      due.setTime(Long.valueOf(dueDate == null ? effectiveDueDate : dueDate));

      if (today.after(due)) {
        values.put(Tasks.COLUMN_OVERDUE, true);
      } else {

        // Add seven days to the current time, and if the due date is now before that,
        // AND not overdue, then it's due soon, right?

        long ONE_DAY = 86400000;
        due.setTime(due.getTime() - (ONE_DAY * 7)); // TODO: Read in from settings class

        values.put(Tasks.COLUMN_DUE_SOON, today.after(due));
      }
    }

    if (deferDate != null || effectiveDeferDate != null) {
      Date defer = new Date();

      defer.setTime(Long.valueOf(deferDate == null ? effectiveDeferDate : deferDate));

      // If the defer date is after today, then the task should be considered 'blocked', or
      // rather, 'blocked by defer'.

      if (defer.after(today)) {
        values.put(Tasks.COLUMN_BLOCKED_BY_DEFER, true);
      }
    }

    return values;
  }

  /**
   * Recursively update the children of a context. Let's just be clear: There are two types of
   * child for a context.
   *
   * Type 1: A context that is a direct descendant of this context. This can be recursively
   * contacted through this function. A.K.A 'context child'.
   * Type 2: A task which lists this context as its context. A.K.A 'task child'.
   *
   * To access a task child of a context child, you need to access it recursively first,
   * through the context child.
   */
  private void updateContextChildren(SQLiteDatabase db, String id, boolean active,
      boolean activeEffective, boolean onHold) {

    String[] columns = new String[]{Contexts.COLUMN_ID, Contexts.COLUMN_ACTIVE,
        Contexts.COLUMN_ON_HOLD,
        Contexts.COLUMN_COUNT_AVAILABLE,
        Contexts.COLUMN_COUNT_CHILDREN,
        Contexts.COLUMN_COUNT_COMPLETED,
        Contexts.COLUMN_COUNT_DUE_SOON,
        Contexts.COLUMN_COUNT_OVERDUE,
        Contexts.COLUMN_COUNT_REMAINING};
    Cursor children = mDBHelper
        .query(db, Contexts.TABLE_NAME, columns, Contexts.COLUMN_PARENT_ID + "=?",
            new String[]{id});

    // If the context is on hold, only its direct (task) children are affected. This _may_ be a
    // bug, but I feel as if this kind of configuration is so rarely used that it won't matter
    // which way I err. Plus, it'll make everyone else happier by keeping this section fast.
    // Also, if the task is directly or indirectly inactive, then the same happens, only this
    // affects all descendants.

    if (onHold || !active || !activeEffective) {
      db.update(Tasks.TABLE_NAME, mBlockedValue, Tasks.COLUMN_CONTEXT + "=?",
          new String[]{id});
    }

    // Update the context children with `activeEffective`, so that this property cascades.

    if (!activeEffective) {
      ContentValues childValues = new ContentValues();
      childValues.put(Contexts.COLUMN_ACTIVE, false);
      childValues.put(Contexts.COLUMN_ACTIVE_EFFECTIVE, false);
      db.update(Contexts.TABLE_NAME, childValues, Contexts.COLUMN_PARENT_ID + "=?",
          new String[]{id});
    }

    // Get counts of task children

    int countChildren, countAvailable, countCompleted, countDueSoon, countOverdue,
        countRemaining;

    Cursor countChildrenCursor = mDBHelper
        .query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_CONTEXT + "=?", new String[]{id});
    Cursor countAvailableCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
        Tasks.COLUMN_CONTEXT + "=? AND " +
            Tasks.COLUMN_DATE_COMPLETED +
            " IS NULL AND " + Tasks.COLUMN_BLOCKED +
            "=0 AND " +
            Tasks.COLUMN_BLOCKED_BY_DEFER +
            "=0 AND " + Tasks.COLUMN_HAS_CHILDREN +
            "=0", new String[]{id});
    Cursor countRemainingCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
        Tasks.COLUMN_CONTEXT + "=? AND " +
            Tasks.COLUMN_DATE_COMPLETED + " IS NULL",
        new String[]{id});
    Cursor countDueSoonCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
        Tasks.COLUMN_CONTEXT + "=? AND " +
            Tasks.COLUMN_DUE_SOON + "=1", new String[]{id});
    Cursor countOverdueCursor = mDBHelper.query(db, Tasks.TABLE_NAME, null,
        Tasks.COLUMN_CONTEXT + "=? AND " +
            Tasks.COLUMN_OVERDUE + "=1", new String[]{id});

    countChildren = countChildrenCursor.getCount();
    countAvailable = countAvailableCursor.getCount();
    countRemaining = countRemainingCursor.getCount();
    countCompleted = countChildren - countRemaining;
    countDueSoon = countDueSoonCursor.getCount();
    countOverdue = countOverdueCursor.getCount();

    countChildrenCursor.close();
    countAvailableCursor.close();
    countRemainingCursor.close();
    countDueSoonCursor.close();
    countOverdueCursor.close();

    // Iterate through the context children to recursively update them.

    while (children.moveToNext()) {

      String childID = mDBHelper.getString(children, Contexts.COLUMN_ID);
      boolean childActive = mDBHelper.getBoolean(children, Contexts.COLUMN_ACTIVE);
      boolean childOnHold = mDBHelper.getBoolean(children, Contexts.COLUMN_ON_HOLD);

      if (!childActive) {
        activeEffective = false;
      }

      updateContextChildren(db, childID, childActive, activeEffective, childOnHold);

      countChildren += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_CHILDREN);
      countAvailable += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_AVAILABLE);
      countCompleted += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_COMPLETED);
      countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_DUE_SOON);
      countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_OVERDUE);
      countRemaining += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_REMAINING);
    }

    children.close();

    ContentValues values = new ContentValues();

    if (countChildren > 0) {
      values.put(Contexts.COLUMN_COUNT_CHILDREN, countChildren);
    }
    if (countAvailable > 0) {
      values.put(Contexts.COLUMN_COUNT_AVAILABLE, countAvailable);
    }
    if (countCompleted > 0) {
      values.put(Contexts.COLUMN_COUNT_COMPLETED, countCompleted);
    }
    if (countDueSoon > 0) {
      values.put(Contexts.COLUMN_COUNT_DUE_SOON, countDueSoon);
    }
    if (countOverdue > 0) {
      values.put(Contexts.COLUMN_COUNT_OVERDUE, countOverdue);
    }
    if (countRemaining > 0) {
      values.put(Contexts.COLUMN_COUNT_REMAINING, countRemaining);
    }

    if (values.size() > 0) {
      db.update(Contexts.TABLE_NAME, values, Contexts.COLUMN_ID + "=?",
          new String[]{id});
    }
  }

  /**
   * Basically a re-do of the origin project recursive tree-caller, but this one has to come
   * after it for various reasons (it relies on data being set which cannot be set until the
   * loop has finished).
   *
   * If a task is blocked, it'll ensure that all of its children are also blocked. Patriotically.
   */
  private void updateTaskBlocked(SQLiteDatabase db, String id, boolean blocked,
      boolean blockedByDefer, String status) {

    blocked = blocked || status.equals("inactive");

    ContentValues childValues = new ContentValues();

    if (blocked) {
      childValues.putAll(mBlockedValue);
    }
    if (blockedByDefer) {
      childValues.put(Tasks.COLUMN_BLOCKED_BY_DEFER, true);
    }

    if (childValues.size() > 0) {
      db.update(Tasks.TABLE_NAME, childValues, Tasks.COLUMN_PARENT_ID + "=?",
          new String[]{id});
    }

    String[] columns = new String[]{Tasks.COLUMN_ID, Tasks.COLUMN_BLOCKED,
        Tasks.COLUMN_BLOCKED_BY_DEFER,
        Tasks.COLUMN_PROJECT_STATUS};
    Cursor children = mDBHelper
        .query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PARENT_ID + "=?",
            new String[]{id});

    while (children.moveToNext()) {

      boolean childBlocked = mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED);
      boolean childBlockedByDefer =
          mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER);
      String childID = mDBHelper.getString(children, Tasks.COLUMN_ID);
      String childStatus = mDBHelper.getString(children, Tasks.COLUMN_PROJECT_STATUS);

      updateTaskBlocked(db, childID, childBlocked, childBlockedByDefer, childStatus);
    }

    children.close();
  }
}