package nu.huw.clarity.db;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import java.util.Date;

import nu.huw.clarity.db.DatabaseContract.Contexts;
import nu.huw.clarity.db.DatabaseContract.Tasks;

/**
 * Once we've pulled in all the sync data, there's a lot of data in columns that needs to be
 * generated by OmniFocus, like countsâ€”these can all be done programatically at the end of a sync,
 * so that's what Omni do.
 *
 * This class contains these methods, which recursively update counts, and also registries of
 * children and the next task the user wants to do.
 */
public class RecursiveColumnUpdater {

    private static final String TAG = RecursiveColumnUpdater.class.getSimpleName();
    ContentValues mBlockedValue = new ContentValues();
    private DatabaseHelper mDBHelper;

    public RecursiveColumnUpdater() {

        mDBHelper = new DatabaseHelper();
        mBlockedValue.put(Tasks.COLUMN_BLOCKED.name, true);
    }

    /**
     * Build the tree into the database, and any other cell data that is built after a sync instead
     * of handed down with the rest of the data.
     *
     * This works in one big recursive traversal of the tree. It takes some time, so it's designed
     * to be called after a full initial sync, or in other occasions where everything is totally
     * messy.
     *
     * Steps:
     * 1. Iterate through each child of a top-level project
     * 2. Fill down the project's effective attributes
     * 3. Push & Pop
     * 4. Fill up child counts
     * 5. Calculate due dates & overdues
     *
     * TODO: Available counts, Next Task, HasChildren (and also, dropped projects)
     */
    public void updateTree() {

        SQLiteDatabase db = mDBHelper.getWritableDatabase();

        String[] projectColumns = new String[]{Tasks.COLUMN_ID.name, Tasks.COLUMN_DATE_DEFER.name,
                                               Tasks.COLUMN_DATE_DUE.name,
                                               Tasks.COLUMN_FLAGGED.name,
                                               Tasks.COLUMN_PROJECT_STATUS.name,
                                               Tasks.COLUMN_TYPE.name};
        Cursor projects = mDBHelper
                .query(db, Tasks.TABLE_NAME, projectColumns, Tasks.COLUMN_PROJECT.name + "='1'");

        // The Cursor object is used to lazy-load SQLite databases, which is important when we're
        // dealing with lots and lots of data (not so much applicable in this case, but you never
        // know).
        //
        // Basically, it's been designed so that its positioning functions (moveToNext,
        // moveToFirst, etc) return booleans for whether they were successful or not. Here, we
        // call `moveToNext()`, and if it returns `true`, then this task has a child we can
        // iterate over.
        //
        // On this first call to `updateProjectChildren()`, we set off the huge recursive update.
        // See
        // the method itself for more details.

        while (projects.moveToNext()) {

            String id        = mDBHelper.getString(projects, Tasks.COLUMN_ID.name);
            String deferDate = mDBHelper.getString(projects, Tasks.COLUMN_DATE_DEFER.name);
            String dueDate   = mDBHelper.getString(projects, Tasks.COLUMN_DATE_DUE.name);
            String flagged   = mDBHelper.getString(projects, Tasks.COLUMN_FLAGGED.name);
            String status    = mDBHelper.getString(projects, Tasks.COLUMN_PROJECT_STATUS.name);
            String type      = mDBHelper.getString(projects, Tasks.COLUMN_TYPE.name);

            updateProjectChildren(db, id, id, deferDate, dueDate, flagged, status, type, false,
                                  false);
        }

        projects.close();

        // Now the same, but for Contexts. Keep in mind that the recursive call in contexts is a
        // little different, see below.

        String[] contextColumns = new String[]{Contexts.COLUMN_ID.name, Contexts.COLUMN_ACTIVE.name,
                                               Contexts.COLUMN_ACTIVE_EFFECTIVE.name,
                                               Contexts.COLUMN_ON_HOLD.name};
        Cursor contexts = mDBHelper.query(db, Contexts.TABLE_NAME, contextColumns,
                                          Contexts.COLUMN_PARENT_ID + " IS NULL");

        while (contexts.moveToNext()) {

            String  id     = mDBHelper.getString(contexts, Contexts.COLUMN_ID.name);
            boolean active = mDBHelper.getBoolean(contexts, Contexts.COLUMN_ACTIVE.name);
            boolean activeEffective =
                    mDBHelper.getBoolean(contexts, Contexts.COLUMN_ACTIVE_EFFECTIVE.name);
            boolean onHold = mDBHelper.getBoolean(contexts, Contexts.COLUMN_ON_HOLD.name);

            updateContextChildren(db, id, active, activeEffective, onHold);
        }

        contexts.close();
        Log.i(TAG, "Database tree fully updated");

        db.close();
    }

    /**
     * Given a database and some other info, find the task's children (if any), and update them
     * with
     * their parent's dateDue and dateDefer. We iterate over any element which lists the task's ID
     * as its parent, and fill in the parent's data in their 'effective' fields.
     *
     * Once this is done, we check to see if the child has any of the same info to pass down to its
     * descendants. If there are any, we update the row.
     *
     * Then, finally, we recursively call the function again on each of these children, until we've
     * eventually descended the tree.
     */
    private void updateProjectChildren(SQLiteDatabase db, String id, String projectID,
                                       String dateDefer, String dateDue, String flagged,
                                       String status, String type, boolean blocked,
                                       boolean blockedByDefer) {

        String[] columns = new String[]{Tasks.COLUMN_ID.name, Tasks.COLUMN_DATE_DEFER.name,
                                        Tasks.COLUMN_DATE_DUE.name, Tasks.COLUMN_FLAGGED.name,
                                        Tasks.COLUMN_DATE_COMPLETED.name,
                                        Tasks.COLUMN_DUE_SOON.name, Tasks.COLUMN_OVERDUE.name,
                                        Tasks.COLUMN_COUNT_AVAILABLE.name,
                                        Tasks.COLUMN_COUNT_CHILDREN.name,
                                        Tasks.COLUMN_COUNT_COMPLETED.name,
                                        Tasks.COLUMN_COUNT_DUE_SOON.name,
                                        Tasks.COLUMN_COUNT_OVERDUE.name,
                                        Tasks.COLUMN_COUNT_REMAINING.name, Tasks.COLUMN_RANK.name,
                                        Tasks.COLUMN_PROJECT_STATUS.name, Tasks.COLUMN_TYPE.name,
                                        Tasks.COLUMN_BLOCKED.name,
                                        Tasks.COLUMN_BLOCKED_BY_DEFER.name};

        Cursor children = mDBHelper
                .query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PARENT_ID.name + "=?",
                       new String[]{id});

        int countChildren, countCompleted, countDueSoon, countOverdue, countRemaining;
        countChildren = countCompleted = countDueSoon = countOverdue = countRemaining = 0;

        long   nextRank = Long.MAX_VALUE;
        String nextID   = "";

        ContentValues values      = new ContentValues();
        ContentValues childValues = new ContentValues();

        // Batch set values for this item's children. Useful for cascading values (particularly
        // when the cascade isn't conditional).

        blocked = blocked || status.equals("inactive");

        if (blocked) {
            childValues.putAll(mBlockedValue);
        }
        if (blockedByDefer) {
            childValues.put(Tasks.COLUMN_BLOCKED_BY_DEFER.name, true);
        }
        if (flagged.equals("1")) {
            childValues.put(Tasks.COLUMN_FLAGGED_EFFECTIVE.name, flagged);
        }
        childValues.put(Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name, dateDefer);
        childValues.put(Tasks.COLUMN_DATE_DUE_EFFECTIVE.name, dateDue);

        if (childValues.size() > 0) {
            db.update(Tasks.TABLE_NAME, childValues, Tasks.COLUMN_PARENT_ID.name + "=?",
                      new String[]{id});
        }

        while (children.moveToNext()) {

            // This section here applies before the recursive call. Basically, all of this code
            // will fill the tree _downward_, with each call pushing deeper into the stack but
            // being able to access the data we've just set.
            //
            // For this case, each level below will be able to access the due date, defer date &
            // flagged status of the level above, which it can then apply to its own children.

            String childID        = mDBHelper.getString(children, Tasks.COLUMN_ID.name);
            String childDateDefer = mDBHelper.getString(children, Tasks.COLUMN_DATE_DEFER.name);
            String childDateDue   = mDBHelper.getString(children, Tasks.COLUMN_DATE_DUE.name);
            String childFlagged   = mDBHelper.getString(children, Tasks.COLUMN_FLAGGED.name);
            long childRank =
                    Long.valueOf(mDBHelper.getString(children, Tasks.COLUMN_RANK.name));

            if (childDateDefer != null) {
                dateDefer = childDateDefer;
            }
            if (childDateDue != null) {
                dateDue = childDateDue;
            }
            if (childFlagged.equals("1")) {
                flagged = childFlagged;
            }

            updateProjectChildren(db, childID, projectID, dateDefer, dateDue, flagged, status, type,
                                  blocked, blockedByDefer);

            // All of the code past the recursive call will happen on the way back out, or up the
            // tree. Once each call returns, this code runs on the level above where the code was
            // just calling to.
            //
            // Here, the level above is able to access the counts for children _of each of its
            // children_. It gets really meta and confusing. Took me like 3-4 hours to work out
            // (but, to be fair, this was more bug-fixing than algorithms).

            // Add count for self (where applicable)
            boolean completed =
                    mDBHelper.getString(children, Tasks.COLUMN_DATE_COMPLETED.name) != null;
            boolean childBlockedByDefer =
                    mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER.name);

            countChildren += 1;
            countCompleted += completed ? 1 : 0;
            countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_DUE_SOON.name);
            countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_OVERDUE.name);
            countRemaining += completed ? 0 : 1;

            // Add counts for children
            countChildren += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_CHILDREN.name);
            countCompleted += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_COMPLETED.name);
            countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_DUE_SOON.name);
            countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_OVERDUE.name);
            countRemaining += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_REMAINING.name);

            // Determine next task by comparing ranks. The lower rank, when converted to a signed
            // 'long', is higher up on the list and thus the next rank. This only applied to
            // non-parallel projects, however. Also, if the task is otherwise blocked or
            // completed, it's not the next task.
            //
            // This code isn't filling upward or downward, but it is reliant on knowing whether
            // the child is blocked by a defer or not, which is calculated in
            // `updateProjectChildren()`.

            if (!completed && !childBlockedByDefer && type.equals("sequential") &&
                childRank < nextRank) {
                nextID = childID;
                nextRank = childRank;
            }
        }

        children.close();

        // Parent project
        values.put(Tasks.COLUMN_PROJECT_ID.name, projectID);

        // Next task
        if (!nextID.equals("")) {
            values.put(Tasks.COLUMN_NEXT.name, nextID);
        }

        // Blocked tasks
        if (type.equals("sequential")) {

            // Set the 'blocked' flag for all entries which list this as a parent, where they
            // aren't the next task.

            db.update(Tasks.TABLE_NAME, mBlockedValue,
                      Tasks.COLUMN_PARENT_ID.name + "=? AND " + Tasks.COLUMN_ID.name + "!=?",
                      new String[]{id, nextID});
        }

        if (status.equals("dropped")) {
            values.putAll(mBlockedValue);
        }

        // Child counts
        if (countChildren > 0) {
            values.put(Tasks.COLUMN_COUNT_CHILDREN.name, countChildren);
            values.put(Tasks.COLUMN_HAS_CHILDREN.name, true);
        }
        if (countCompleted > 0) {
            values.put(Tasks.COLUMN_COUNT_COMPLETED.name, countCompleted);
        }
        if (countDueSoon > 0) {
            values.put(Tasks.COLUMN_COUNT_DUE_SOON.name, countDueSoon);
        }
        if (countOverdue > 0) {
            values.put(Tasks.COLUMN_COUNT_OVERDUE.name, countOverdue);
        }
        if (countRemaining > 0) {
            values.put(Tasks.COLUMN_COUNT_REMAINING.name, countRemaining);
        }

        // Overdue & Due Soon
        values.putAll(determineDues(db, id));

        // Update
        if (values.size() > 0) {
            db.update(Tasks.TABLE_NAME, values, Tasks.COLUMN_ID.name + "=?", new String[]{id});
        }
    }

    /**
     * Determines whether a given task (by ID) is due soon or overdue. Returns columns to update.
     */
    private ContentValues determineDues(SQLiteDatabase db, String id) {

        ContentValues values = new ContentValues();

        Cursor dates = mDBHelper.query(db, Tasks.TABLE_NAME,
                                       new String[]{Tasks.COLUMN_DATE_COMPLETED.name,
                                                    Tasks.COLUMN_DATE_DEFER.name,
                                                    Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name,
                                                    Tasks.COLUMN_DATE_DUE.name,
                                                    Tasks.COLUMN_DATE_DUE_EFFECTIVE.name},
                                       Tasks.COLUMN_ID.name + "=?", new String[]{id});

        dates.moveToNext();

        String deferDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER.name);
        String effectiveDeferDate =
                mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name);
        String  dueDate          = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE.name);
        String  effectiveDueDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE_EFFECTIVE.name);
        boolean completed        =
                mDBHelper.getString(dates, Tasks.COLUMN_DATE_COMPLETED.name) != null;
        Date    today            = new Date();

        if (!completed && (dueDate != null || effectiveDueDate != null)) {
            Date due = new Date();

            // If we don't have a normal due date, then we default back on the effective due date.
            // That one becomes the one to compare with the current date to determine Due Soon
            // and Overdue. Look up the ternary operator if this is confusing.

            due.setTime(Long.valueOf(dueDate == null ? effectiveDueDate : dueDate));

            if (today.after(due)) {
                values.put(Tasks.COLUMN_OVERDUE.name, true);
            } else {

                // Add seven days to the current time, and if the due date is now before that,
                // AND not overdue, then it's due soon, right?

                long ONE_DAY = 86400000;
                due.setTime(due.getTime() - (ONE_DAY * 7)); // TODO: Read in from settings class

                values.put(Tasks.COLUMN_DUE_SOON.name, today.after(due));
            }
        }

        if (deferDate != null || effectiveDeferDate != null) {
            Date defer = new Date();

            defer.setTime(Long.valueOf(deferDate == null ? effectiveDeferDate : deferDate));

            // If the defer date is after today, then the task should be considered 'blocked', or
            // rather, 'blocked by defer'.

            if (defer.after(today)) {
                values.put(Tasks.COLUMN_BLOCKED_BY_DEFER.name, true);
            }
        }

        return values;
    }

    /**
     * Recursively update the children of a context. Let's just be clear: There are two types of
     * child for a context.
     *
     * Type 1: A context that is a direct descendant of this context. This can be recursively
     * contacted through this function. A.K.A 'context child'.
     * Type 2: A task which lists this context as its context. A.K.A 'task child'.
     *
     * To access a task child of a context child, you need to access it recursively first,
     * through the context child.
     */
    private void updateContextChildren(SQLiteDatabase db, String id, boolean active,
                                       boolean activeEffective, boolean onHold) {

        String[] columns = new String[]{Contexts.COLUMN_ID.name, Contexts.COLUMN_ACTIVE.name,
                                        Contexts.COLUMN_ON_HOLD.name,
                                        Contexts.COLUMN_COUNT_CHILDREN.name,
                                        Contexts.COLUMN_COUNT_COMPLETED.name,
                                        Contexts.COLUMN_COUNT_DUE_SOON.name,
                                        Contexts.COLUMN_COUNT_OVERDUE.name,
                                        Contexts.COLUMN_COUNT_REMAINING.name};
        Cursor children = mDBHelper
                .query(db, Contexts.TABLE_NAME, columns, Contexts.COLUMN_PARENT_ID.name + "=?",
                       new String[]{id});

        // If the context is on hold, only its direct (task) children are affected. This _may_ be a
        // bug, but I feel as if this kind of configuration is so rarely used that it won't matter
        // which way I err. Plus, it'll make everyone else happier by keeping this section fast.
        // Also, if the task is directly or indirectly inactive, then the same happens, only this
        // affects all descendants.

        if (onHold || !active || !activeEffective) {
            db.update(Tasks.TABLE_NAME, mBlockedValue, Tasks.COLUMN_CONTEXT + "=?",
                      new String[]{id});
        }

        // Update the context children with `activeEffective`, so that this property cascades.

        if (!activeEffective) {
            ContentValues childValues = new ContentValues();
            childValues.put(Contexts.COLUMN_ACTIVE_EFFECTIVE.name, false);
            db.update(Contexts.TABLE_NAME, childValues, Contexts.COLUMN_PARENT_ID.name + "=?",
                      new String[]{id});
        }

        // Get counts of task children

        int countChildren, countCompleted, countDueSoon, countOverdue, countRemaining;

        Cursor countChildrenCursor = mDBHelper
                .query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_CONTEXT + "=?", new String[]{id});
        Cursor countRemainingCursor =
                mDBHelper.query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_CONTEXT + "=? AND " +
                                                            Tasks.COLUMN_DATE_COMPLETED +
                                                            " IS NULL", new String[]{id});
        Cursor countDueSoonCursor =
                mDBHelper.query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_CONTEXT + "=? AND " +
                                                            Tasks.COLUMN_DUE_SOON + "=1",
                                new String[]{id});
        Cursor countOverdueCursor =
                mDBHelper.query(db, Tasks.TABLE_NAME, null, Tasks.COLUMN_CONTEXT + "=? AND " +
                                                            Tasks.COLUMN_OVERDUE + "=1",
                                new String[]{id});

        countChildren = countChildrenCursor.getCount();
        countRemaining = countRemainingCursor.getCount();
        countCompleted = countChildren - countRemaining;
        countDueSoon = countDueSoonCursor.getCount();
        countOverdue = countOverdueCursor.getCount();

        countChildrenCursor.close();
        countRemainingCursor.close();
        countDueSoonCursor.close();
        countOverdueCursor.close();

        // Iterate through the context children to recursively update them.

        while (children.moveToNext()) {

            String  childID     = mDBHelper.getString(children, Contexts.COLUMN_ID.name);
            boolean childActive = mDBHelper.getBoolean(children, Contexts.COLUMN_ACTIVE.name);
            boolean childOnHold = mDBHelper.getBoolean(children, Contexts.COLUMN_ON_HOLD.name);

            if (!childActive) {
                activeEffective = false;
            }

            updateContextChildren(db, childID, childActive, activeEffective, childOnHold);

            countChildren += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_CHILDREN.name);
            countCompleted += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_COMPLETED.name);
            countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_DUE_SOON.name);
            countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_OVERDUE.name);
            countRemaining += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_REMAINING.name);
        }

        children.close();

        ContentValues values = new ContentValues();

        if (countChildren > 0) {
            values.put(Tasks.COLUMN_COUNT_CHILDREN.name, countChildren);
            values.put(Tasks.COLUMN_HAS_CHILDREN.name, true);
        }
        if (countCompleted > 0) {
            values.put(Tasks.COLUMN_COUNT_COMPLETED.name, countCompleted);
        }
        if (countDueSoon > 0) {
            values.put(Tasks.COLUMN_COUNT_DUE_SOON.name, countDueSoon);
        }
        if (countOverdue > 0) {
            values.put(Tasks.COLUMN_COUNT_OVERDUE.name, countOverdue);
        }
        if (countRemaining > 0) {
            values.put(Tasks.COLUMN_COUNT_REMAINING.name, countRemaining);
        }

        if (values.size() > 0) {
            db.update(Contexts.TABLE_NAME, values, Contexts.COLUMN_ID.name + "=?",
                      new String[]{id});
        }
    }
}