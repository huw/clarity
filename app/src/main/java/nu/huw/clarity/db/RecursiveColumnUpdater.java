package nu.huw.clarity.db;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import java.util.Date;

/**
 * Once we've pulled in all the sync data, there's a lot of data in columns that needs to be generated by OmniFocus,
 * like countsâ€”these can all be done programatically at the end of a sync, so that's what Omni do.
 *
 * This class contains these methods, which recursively update counts, and also registries of children and the next task
 * the user wants to do.
 */
public class RecursiveColumnUpdater {

    private static final String TAG = RecursiveColumnUpdater.class.getSimpleName();
    private DatabaseHelper mDBHelper;

    public RecursiveColumnUpdater() {

        mDBHelper = new DatabaseHelper();
    }

    /**
     * Build the tree into the database, and any other cell data that is built after a sync instead of handed down with
     * the rest of the data.
     *
     * Order of operations: 1. Recursively move down the tree from each project, updating children with defer/due dates
     * and flags in 'dateDueEffective' and the like. 1.1 Run through each child, and calculate its due soon/overdue
     * columns using the new data. 2. Each parent gets the number of children for each count. 3. Each child determines
     * if it's blocked by checking its parent's 'nextTask' column. 4. Each child updates its parent's and context's
     * 'available' column.
     */
    public void updateTree() {

        SQLiteDatabase db = mDBHelper.getWritableDatabase();

        updateEffectiveAttributes(db);
        updateParentCounts(db);

        db.close();
    }

    /**
     * An 'effective' attribute is where a parent has a certain attribute that should cascade down into all of its
     * children. If a project is due at 9am, then so should all of its children be, and their children, and so on.
     *
     * This function is a flow controller for the recursive function `updateChildEffectiveAttributes()`, which does the
     * dirty work.
     */
    public void updateEffectiveAttributes(SQLiteDatabase db) {

        Cursor projects = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME,
                                          new String[]{DatabaseContract.Tasks.COLUMN_ID.name,
                                                       DatabaseContract.Tasks.COLUMN_DATE_DEFER.name,
                                                       DatabaseContract.Tasks.COLUMN_DATE_DUE.name,
                                                       DatabaseContract.Tasks.COLUMN_FLAGGED.name},
                                          DatabaseContract.Tasks.COLUMN_PROJECT.name + "='1'");

        // The Cursor object is used to lazy-load SQLite databases, which
        // is important when we're dealing with lots and lots of data (not
        // so much applicable in this case, but you never know).
        //
        // Basically, it's been designed so that its positioning functions
        // (moveToNext, moveToFirst, etc) return booleans for whether they
        // were successful or not. Here, we call `moveToNext()`, and if it
        // returns `true`, then this task has a child we can iterate over.
        //
        // On this first call to `updateChildren()`, we set off the huge
        // recursive update. See the method itself for more details.

        while (projects.moveToNext()) {

            String id        = mDBHelper.getString(projects, DatabaseContract.Tasks.COLUMN_ID.name);
            String deferDate = mDBHelper.getString(projects, DatabaseContract.Tasks.COLUMN_DATE_DEFER.name);
            String dueDate   = mDBHelper.getString(projects, DatabaseContract.Tasks.COLUMN_DATE_DUE.name);
            String flagged   = mDBHelper.getString(projects, DatabaseContract.Tasks.COLUMN_FLAGGED.name);

            updateChildEffectiveAttributes(db, id, deferDate, dueDate, flagged);
        }

        projects.close();
        Log.i(TAG, "Effective defer dates, due dates, flags, due soons and overdues updated");
    }

    /**
     * Given a database and some other info, find the task's children (if any), and update them with their parent's
     * dateDue and dateDefer. We iterate over any element which lists the task's ID as its parent, and fill in the
     * parent's data in their 'effective' fields.
     *
     * Once this is done, we check to see if the child has any of the same info to pass down to its descendants. If
     * there are any, we update the row.
     *
     * Then, finally, we recursively call the function again on each of these children, until we've eventually descended
     * the tree.
     */
    private void updateChildEffectiveAttributes(SQLiteDatabase db, String id, String dateDefer, String dateDue,
                                                String flagged) {

        Cursor children = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME,
                                          new String[]{DatabaseContract.Tasks.COLUMN_ID.name,
                                                       DatabaseContract.Tasks.COLUMN_DATE_DEFER.name,
                                                       DatabaseContract.Tasks.COLUMN_DATE_DUE.name,
                                                       DatabaseContract.Tasks.COLUMN_FLAGGED.name},
                                          DatabaseContract.Tasks.COLUMN_PARENT_ID.name + "=?", new String[]{id});

        while (children.moveToNext()) {

            String childID        = mDBHelper.getString(children, DatabaseContract.Tasks.COLUMN_ID.name);
            String childDateDefer = mDBHelper.getString(children, DatabaseContract.Tasks.COLUMN_DATE_DEFER.name);
            String childDateDue   = mDBHelper.getString(children, DatabaseContract.Tasks.COLUMN_DATE_DUE.name);
            String childFlagged   = mDBHelper.getString(children, DatabaseContract.Tasks.COLUMN_FLAGGED.name);

            ContentValues values = new ContentValues();

            values.put(DatabaseContract.Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name, dateDefer);
            values.put(DatabaseContract.Tasks.COLUMN_FLAGGED_EFFECTIVE.name, flagged);
            values.put(DatabaseContract.Tasks.COLUMN_DATE_DUE_EFFECTIVE.name, dateDue);

            if (values.size() > 0) {
                db.update(DatabaseContract.Tasks.TABLE_NAME, values, DatabaseContract.Tasks.COLUMN_ID.name + "=?",
                          new String[]{childID});
            }

            if (childDateDefer != null) {
                dateDefer = childDateDefer;
            }
            if (childDateDue != null) {
                dateDue = childDateDue;
            }
            if (childFlagged.equals("1")) {
                flagged = childFlagged;
            }

            updateChildEffectiveAttributes(db, childID, dateDefer, dateDue, flagged);
        }

        children.close();

        /**
         * Step 1.5: Overdue/due soon
         */
        Cursor dueDates = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME,
                                          new String[]{DatabaseContract.Tasks.COLUMN_DATE_DUE.name,
                                                       DatabaseContract.Tasks.COLUMN_DATE_DUE_EFFECTIVE.name},
                                          DatabaseContract.Tasks.COLUMN_ID.name + "=?", new String[]{id});

        dueDates.moveToNext();

        String normalDate    = mDBHelper.getString(dueDates, DatabaseContract.Tasks.COLUMN_DATE_DUE.name);
        String effectiveDate = mDBHelper.getString(dueDates, DatabaseContract.Tasks.COLUMN_DATE_DUE_EFFECTIVE.name);

        if (normalDate != null || effectiveDate != null) {
            Date          dueDate = new Date();
            Date          today   = new Date();
            ContentValues values  = new ContentValues();

            // If we don't have a normal due date, then we default back on the
            // effective due date. That one becomes the one to compare with the
            // the current date to determine Due Soon and Overdue. Look up the
            // ternary operator if this is confusing.

            dueDate.setTime(Long.valueOf(normalDate == null ? effectiveDate : normalDate));

            if (today.after(dueDate)) {
                values.put(DatabaseContract.Tasks.COLUMN_OVERDUE.name, true);
            } else {

                // Add seven days to the current time, and if the due date is now
                // before that, AND not overdue, then it's due soon, right?

                long ONE_DAY = 86400000;
                today.setTime(today.getTime() + (ONE_DAY * 7)); // TODO: Read in from settings class

                values.put(DatabaseContract.Tasks.COLUMN_DUE_SOON.name, today.after(dueDate));
            }

            db.update(DatabaseContract.Tasks.TABLE_NAME, values, DatabaseContract.Tasks.COLUMN_ID.name + "=?",
                      new String[]{id});
        }
    }

    /**
     * Parents have counts of the numbers of each type of child they have, which are displayed to the user as useful
     * information for organisation.
     */
    public void updateParentCounts(SQLiteDatabase db) {

        Cursor allParents = mDBHelper
                .query(db, DatabaseContract.Tasks.TABLE_NAME, new String[]{DatabaseContract.Tasks.COLUMN_ID.name},

                       // This SQL statement will get all parents.
                       // How? It finds all entries where their ID is found in a child's
                       // PARENT_ID column. That's some goddamn SQL magic, son.

                       DatabaseContract.Tasks.COLUMN_ID.name + " IN (SELECT " +
                       DatabaseContract.Tasks.COLUMN_PARENT_ID.name + " FROM " +
                       DatabaseContract.Tasks.TABLE_NAME + ")");

        while (allParents.moveToNext()) {
            String id = mDBHelper.getString(allParents, DatabaseContract.Tasks.COLUMN_ID.name);

            // Gets all remaining items ordered by rank. This was going to
            // be a full list of children, but I realised I could re-use
            // this cursor for the 'next' parameter. So it's kinda cool.

            Cursor remaining = db.query(DatabaseContract.Tasks.TABLE_NAME, null,
                                        DatabaseContract.Tasks.COLUMN_PARENT_ID.name + "=? AND " +
                                        DatabaseContract.Tasks.COLUMN_DATE_COMPLETED + " IS NULL", new String[]{id},
                                        null, null, DatabaseContract.Tasks.COLUMN_RANK.name + " ASC");

            // This bit gets the first child, when the list of children is
            // ordered by the rank. That child will be the 'next' task that
            // the user wants to complete, as per OmniFocus.

            String next = "";
            if (remaining.moveToFirst()) {
                next = mDBHelper.getString(remaining, DatabaseContract.Tasks.COLUMN_ID.name);
            }

            // These three just get row counts straight from the query

            int countCompleted = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME, null,
                                                 DatabaseContract.Tasks.COLUMN_PARENT_ID.name + "=? AND " +
                                                 DatabaseContract.Tasks.COLUMN_DATE_COMPLETED.name + " IS NOT NULL",
                                                 new String[]{id}).getCount();

            int countDueSoon = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME, null,
                                               DatabaseContract.Tasks.COLUMN_PARENT_ID.name + "=? AND " +
                                               DatabaseContract.Tasks.COLUMN_DUE_SOON.name + "=1", new String[]{id})
                                        .getCount();

            int countOverdue = mDBHelper.query(db, DatabaseContract.Tasks.TABLE_NAME, null,
                                               DatabaseContract.Tasks.COLUMN_PARENT_ID.name + "=? AND " +
                                               DatabaseContract.Tasks.COLUMN_OVERDUE.name + "=1 AND " +

                                               // Only get an overdue count for tasks that aren't complete

                                               DatabaseContract.Tasks.COLUMN_DATE_COMPLETED.name + " IS NULL",
                                               new String[]{id}).getCount();

            // The child count is always the number remaining (not completed)
            // plus the number of completed. So just build it here.

            int countRemaining = remaining.getCount();
            int countChildren  = countRemaining + countCompleted;

            ContentValues values = new ContentValues();
            values.put(DatabaseContract.Tasks.COLUMN_COUNT_CHILDREN.name, countChildren);
            values.put(DatabaseContract.Tasks.COLUMN_COUNT_COMPLETED.name, countCompleted);
            values.put(DatabaseContract.Tasks.COLUMN_COUNT_DUE_SOON.name, countDueSoon);
            values.put(DatabaseContract.Tasks.COLUMN_COUNT_OVERDUE.name, countOverdue);
            values.put(DatabaseContract.Tasks.COLUMN_COUNT_REMAINING.name, countRemaining);
            values.put(DatabaseContract.Tasks.COLUMN_HAS_CHILDREN.name, 1);
            values.put(DatabaseContract.Tasks.COLUMN_NEXT.name, next);

            db.update(DatabaseContract.Tasks.TABLE_NAME, values, DatabaseContract.Tasks.COLUMN_ID + "=?",
                      new String[]{id});
        }
        allParents.close();

        Log.i(TAG, "All parent counts (except blocked) updated");
    }
}
