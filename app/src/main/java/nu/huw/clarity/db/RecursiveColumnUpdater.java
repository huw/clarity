package nu.huw.clarity.db;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import java.util.Date;

import nu.huw.clarity.db.DatabaseContract.Tasks;

/**
 * Once we've pulled in all the sync data, there's a lot of data in columns that needs to be
 * generated by OmniFocus, like countsâ€”these can all be done programatically at the end of a sync,
 * so that's what Omni do.
 *
 * This class contains these methods, which recursively update counts, and also registries of
 * children and the next task the user wants to do.
 */
public class RecursiveColumnUpdater {

    private static final String TAG = RecursiveColumnUpdater.class.getSimpleName();
    private DatabaseHelper mDBHelper;

    public RecursiveColumnUpdater() {

        mDBHelper = new DatabaseHelper();
    }

    /**
     * Build the tree into the database, and any other cell data that is built after a sync instead
     * of handed down with the rest of the data.
     *
     * This works in one big recursive traversal of the tree. It takes some time, so it's designed
     * to be called after a full initial sync, or in other occasions where everything is totally
     * messy.
     *
     * Steps:
     * 1. Iterate through each child of a top-level project
     * 2. Fill down the project's effective attributes
     * 3. Push & Pop
     * 4. Fill up child counts
     * 5. Calculate due dates & overdues
     *
     * TODO: Available counts, Next Task, HasChildren (and also, dropped projects)
     */
    public void updateTree() {

        SQLiteDatabase db = mDBHelper.getWritableDatabase();

        String[] columns = new String[]{Tasks.COLUMN_ID.name, Tasks.COLUMN_DATE_DEFER.name,
                                        Tasks.COLUMN_DATE_DUE.name, Tasks.COLUMN_FLAGGED.name,
                                        Tasks.COLUMN_PROJECT_STATUS.name, Tasks.COLUMN_TYPE.name};
        Cursor projects =
                mDBHelper.query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PROJECT.name + "='1'");

        // The Cursor object is used to lazy-load SQLite databases, which is important when we're
        // dealing with lots and lots of data (not so much applicable in this case, but you never
        // know).
        //
        // Basically, it's been designed so that its positioning functions (moveToNext,
        // moveToFirst, etc) return booleans for whether they were successful or not. Here, we
        // call `moveToNext()`, and if it returns `true`, then this task has a child we can
        // iterate over.
        //
        // On this first call to `updateChildren()`, we set off the huge recursive update. See
        // the method itself for more details.

        while (projects.moveToNext()) {

            String id        = mDBHelper.getString(projects, Tasks.COLUMN_ID.name);
            String deferDate = mDBHelper.getString(projects, Tasks.COLUMN_DATE_DEFER.name);
            String dueDate   = mDBHelper.getString(projects, Tasks.COLUMN_DATE_DUE.name);
            String flagged   = mDBHelper.getString(projects, Tasks.COLUMN_FLAGGED.name);
            String status    = mDBHelper.getString(projects, Tasks.COLUMN_PROJECT_STATUS.name);
            String type      = mDBHelper.getString(projects, Tasks.COLUMN_TYPE.name);

            updateChildren(db, id, id, deferDate, dueDate, flagged, status, type, false, false);
        }

        projects.close();
        Log.i(TAG, "Database tree fully updated");

        db.close();
    }

    /**
     * Given a database and some other info, find the task's children (if any), and update them
     * with
     * their parent's dateDue and dateDefer. We iterate over any element which lists the task's ID
     * as its parent, and fill in the parent's data in their 'effective' fields.
     *
     * Once this is done, we check to see if the child has any of the same info to pass down to its
     * descendants. If there are any, we update the row.
     *
     * Then, finally, we recursively call the function again on each of these children, until we've
     * eventually descended the tree.
     */
    private void updateChildren(SQLiteDatabase db, String id, String projectID, String dateDefer,
                                String dateDue, String flagged, String status, String type,
                                boolean blocked, boolean blockedByDefer) {

        String[] columns = new String[]{Tasks.COLUMN_ID.name, Tasks.COLUMN_DATE_DEFER.name,
                                        Tasks.COLUMN_DATE_DUE.name, Tasks.COLUMN_FLAGGED.name,
                                        Tasks.COLUMN_DATE_COMPLETED.name,
                                        Tasks.COLUMN_DUE_SOON.name, Tasks.COLUMN_OVERDUE.name,
                                        Tasks.COLUMN_COUNT_AVAILABLE.name,
                                        Tasks.COLUMN_COUNT_CHILDREN.name,
                                        Tasks.COLUMN_COUNT_COMPLETED.name,
                                        Tasks.COLUMN_COUNT_DUE_SOON.name,
                                        Tasks.COLUMN_COUNT_OVERDUE.name,
                                        Tasks.COLUMN_COUNT_REMAINING.name, Tasks.COLUMN_RANK.name,
                                        Tasks.COLUMN_PROJECT_STATUS.name, Tasks.COLUMN_TYPE.name,
                                        Tasks.COLUMN_BLOCKED.name,
                                        Tasks.COLUMN_BLOCKED_BY_DEFER.name};

        Cursor children = mDBHelper
                .query(db, Tasks.TABLE_NAME, columns, Tasks.COLUMN_PARENT_ID.name + "=?",
                       new String[]{id});

        int countChildren, countCompleted, countDueSoon, countOverdue, countRemaining;
        countChildren = countCompleted = countDueSoon = countOverdue = countRemaining = 0;

        long   nextRank = Long.MAX_VALUE;
        String nextID   = "";

        ContentValues values      = new ContentValues();
        ContentValues childValues = new ContentValues();

        // Batch set values for this item's children. Useful for cascading values (particularly
        // when the cascade isn't conditional).

        if (blocked) {
            childValues.put(Tasks.COLUMN_BLOCKED.name, true);
        }
        if (blockedByDefer) {
            childValues.put(Tasks.COLUMN_BLOCKED_BY_DEFER.name, true);
        }
        childValues.put(Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name, dateDefer);
        childValues.put(Tasks.COLUMN_DATE_DUE_EFFECTIVE.name, dateDue);
        childValues.put(Tasks.COLUMN_FLAGGED_EFFECTIVE.name, flagged);

        if (childValues.size() > 0) {
            db.update(Tasks.TABLE_NAME, childValues, Tasks.COLUMN_PARENT_ID.name + "=?",
                      new String[]{id});
        }

        while (children.moveToNext()) {

            // This section here applies before the recursive call. Basically, all of this code
            // will fill the tree _downward_, with each call pushing deeper into the stack but
            // being able to access the data we've just set.
            //
            // For this case, each level below will be able to access the due date, defer date &
            // flagged status of the level above, which it can then apply to its own children.

            String  childID        = mDBHelper.getString(children, Tasks.COLUMN_ID.name);
            String  childDateDefer = mDBHelper.getString(children, Tasks.COLUMN_DATE_DEFER.name);
            String  childDateDue   = mDBHelper.getString(children, Tasks.COLUMN_DATE_DUE.name);
            String  childFlagged   = mDBHelper.getString(children, Tasks.COLUMN_FLAGGED.name);
            long    childRank      =
                    Long.valueOf(mDBHelper.getString(children, Tasks.COLUMN_RANK.name));
            boolean childBlocked   = mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED.name);
            boolean childBlockedByDefer =
                    mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER.name);

            if (childDateDefer != null) {
                dateDefer = childDateDefer;
            }
            if (childDateDue != null) {
                dateDue = childDateDue;
            }
            if (childFlagged.equals("1")) {
                flagged = childFlagged;
            }

            updateChildren(db, childID, projectID, dateDefer, dateDue, flagged, status, type,
                           childBlocked, childBlockedByDefer);

            // All of the code past the recursive call will happen on the way back out, or up the
            // tree. Once each call returns, this code runs on the level above where the code was
            // just calling to.
            //
            // Here, the level above is able to access the counts for children _of each of its
            // children_. It gets really meta and confusing. Took me like 3-4 hours to work out
            // (but, to be fair, this was more bug-fixing than algorithms).

            // Add count for self (where applicable)
            boolean completed =
                    mDBHelper.getString(children, Tasks.COLUMN_DATE_COMPLETED.name) != null;
            childBlockedByDefer =
                    mDBHelper.getBoolean(children, Tasks.COLUMN_BLOCKED_BY_DEFER.name);

            countChildren += 1;
            countCompleted += completed ? 1 : 0;
            countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_DUE_SOON.name);
            countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_OVERDUE.name);
            countRemaining += completed ? 0 : 1;

            // Add counts for children
            countChildren += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_CHILDREN.name);
            countCompleted += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_COMPLETED.name);
            countDueSoon += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_DUE_SOON.name);
            countOverdue += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_OVERDUE.name);
            countRemaining += mDBHelper.getInt(children, Tasks.COLUMN_COUNT_REMAINING.name);

            // Determine next task by comparing ranks. The lower rank, when converted to a signed
            // 'long', is higher up on the list and thus the next rank. This only applied to
            // non-parallel projects, however. Also, if the task is otherwise blocked or
            // completed, it's not the next task.
            //
            // This code isn't filling upward or downward, but it is reliant on knowing whether
            // the child is blocked by a defer or not, which is calculated in `updateChildren()`.

            if (!completed && !childBlockedByDefer && type.equals("sequential") &&
                childRank < nextRank) {
                nextID = childID;
                nextRank = childRank;
            }
        }

        children.close();

        // Parent project
        values.put(Tasks.COLUMN_PROJECT_ID.name, projectID);

        // Next task
        if (!nextID.equals("")) {
            values.put(Tasks.COLUMN_NEXT.name, nextID);
        }

        // Blocked tasks
        if (type.equals("sequential")) {

            // Set the 'blocked' flag for all entries which list this as a parent, where they
            // aren't the next task.

            ContentValues blockedValue = new ContentValues();
            blockedValue.put(Tasks.COLUMN_BLOCKED.name, true);

            db.update(Tasks.TABLE_NAME, blockedValue,
                      Tasks.COLUMN_PARENT_ID.name + "=? AND " + Tasks.COLUMN_ID.name + "!=?",
                      new String[]{id, nextID});
        }

        if (status.equals("dropped")) {
            values.put(Tasks.COLUMN_BLOCKED.name, true);
        }

        // Child counts
        if (countChildren > 0) {
            values.put(Tasks.COLUMN_COUNT_CHILDREN.name, countChildren);
            values.put(Tasks.COLUMN_HAS_CHILDREN.name, true);
        }
        if (countCompleted > 0) {
            values.put(Tasks.COLUMN_COUNT_COMPLETED.name, countCompleted);
        }
        if (countDueSoon > 0) {
            values.put(Tasks.COLUMN_COUNT_DUE_SOON.name, countDueSoon);
        }
        if (countOverdue > 0) {
            values.put(Tasks.COLUMN_COUNT_OVERDUE.name, countOverdue);
        }
        if (countRemaining > 0) {
            values.put(Tasks.COLUMN_COUNT_REMAINING.name, countRemaining);
        }

        // Overdue & Due Soon
        values.putAll(determineDues(db, id));

        // Update
        if (values.size() > 0) {
            db.update(Tasks.TABLE_NAME, values, Tasks.COLUMN_ID.name + "=?", new String[]{id});
        }
    }

    /**
     * Determines whether a given task (by ID) is due soon or overdue. Returns columns to update.
     */
    private ContentValues determineDues(SQLiteDatabase db, String id) {

        ContentValues values = new ContentValues();

        Cursor dates = mDBHelper.query(db, Tasks.TABLE_NAME,
                                       new String[]{Tasks.COLUMN_DATE_DEFER.name,
                                                    Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name,
                                                    Tasks.COLUMN_DATE_DUE.name,
                                                    Tasks.COLUMN_DATE_DUE_EFFECTIVE.name},
                                       Tasks.COLUMN_ID.name + "=?", new String[]{id});

        dates.moveToNext();

        String deferDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER.name);
        String effectiveDeferDate =
                mDBHelper.getString(dates, Tasks.COLUMN_DATE_DEFER_EFFECTIVE.name);
        String dueDate          = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE.name);
        String effectiveDueDate = mDBHelper.getString(dates, Tasks.COLUMN_DATE_DUE_EFFECTIVE.name);
        Date   today            = new Date();

        if (dueDate != null || effectiveDueDate != null) {
            Date due = new Date();

            // If we don't have a normal due date, then we default back on the effective due date.
            // That one becomes the one to compare with the current date to determine Due Soon
            // and Overdue. Look up the ternary operator if this is confusing.

            due.setTime(Long.valueOf(dueDate == null ? effectiveDueDate : dueDate));

            if (today.after(due)) {
                values.put(Tasks.COLUMN_OVERDUE.name, true);
            } else {

                // Add seven days to the current time, and if the due date is now before that,
                // AND not overdue, then it's due soon, right?

                long ONE_DAY = 86400000;
                due.setTime(due.getTime() - (ONE_DAY * 7)); // TODO: Read in from settings class

                values.put(Tasks.COLUMN_DUE_SOON.name, today.after(due));
            }
        }

        if (deferDate != null || effectiveDeferDate != null) {
            Date defer = new Date();

            defer.setTime(Long.valueOf(deferDate == null ? effectiveDeferDate : deferDate));

            // If the defer date is after today, then the task should be considered 'blocked', or
            // rather, 'blocked by defer'.

            if (defer.after(today)) {
                values.put(Tasks.COLUMN_BLOCKED_BY_DEFER.name, true);
            }
        }

        return values;
    }
}